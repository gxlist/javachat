# 分布式

## 分布式系统的的应用

分布式系统一致性，分布式事务，分布式存储，分布式计算

## 进程间通信有哪几种方式？

1）管道（Pipe），2）命名管道（named pipe），3）信号（Signal），4）消息（Message）队列，5）共享内存，6）内存映射（mapped memory），7）信号量（semaphore），8）套接口（Socket）

## CAP定理说一下，为什么三者只能选二，为什么分区容忍性必须保证。 

一致性，可用性和分区容忍性不可以同时实现。CP系统包括zk,AP系统包括。

分布式系统的CAP不能同时实现，传统的OLTP业务要求关系型数据库满足CA即可，大型互联网平台的一个功能往往需要调用多个服务和数据库，业务上满足AP就必须把C降级为最终一致性。

## 分布式系统常见的问题有哪些？

通信异常(丢包或延时)，网络分区(局部集群)，三态(成败和超时)和节点故障(宕机或假死)。

## 什么是base理论？

BASE理论是对CA权衡的结果，三要素包括：基本可用(响应延时和功能降级)，弱状态(副本数据同步的延时)和最终一致性(包括因果一致性、读己之所写、会话一致性、单调读/写一致性)。

## 一致性哈希算法是什么？

将机器地址映射到0-2^31，添加数据时，顺时针寻找哈希映射点，添加到指定的机器。如果扩容要转移太多数据而不方便，就使用150个虚拟的哈希点。

## 网络分区问题
主节点复活，会抢夺资源的使用权，系统功能失调。解决方案包括：(高可用的)第三方检测服务器仲裁，周期性ping主从机，如果有异常，则暂停业务操作，多次重试后重启或者退出。租期机制，原先的从服务器开始行使主服务器的功能后，给原先的主服务器发送新的租期，让原租期失效。

## 什么是幂等性，以及解决方案？

幂等性是重试的业务不会产生不良后果，方案是唯一ID。

## 常用的hash算法有哪些？

1. 加法hash：所谓的加法Hash就是把输入元素一个一个的加起来构成最后的结果。
1. 位运算hash：这类型Hash函数通过利用各种位运算（常见的是移位和异或）来充分的混合输入元素。
1. 乘法hash：33*hash + key.charAt(i)。

## 分布式ID生成方案

- 数据库主键生成(mysql替换插入唯一键，获取last_insert_id)，

    ```
    生成表
    CREATE TABLE `Tickets64` (
      `id` bigint(20) unsigned NOT NULL auto_increment,
      `stub` char(1) NOT NULL default '',
      PRIMARY KEY  (`id`),
      UNIQUE KEY `stub` (`stub`)
    ) ENGINE=MyISAM
    业务生成
    REPLACE INTO Tickets64 (stub) VALUES ('a');
    SELECT LAST_INSERT_ID();

    多机配置为：
    TicketServer1:
    auto-increment-increment = 2
    auto-increment-offset = 1

    TicketServer2:
    auto-increment-increment = 2
    auto-increment-offset = 2
    ```
- uuid及其组合时间戳的变种

-  snowflake算法生成ID(时间毫秒数+机器号+流水号)

  时间--用前面41 bit来表示时间，精确到毫秒，可以表示69年的数据

  机器ID--用10 bit来表示，也就是说可以部署1024台机器

  序列号--用12 bit来表示，意味着每台机器，每毫秒最多可以生成4096个ID

- redis方法

  参考snowflake算法，id分为三段：时间，分片号，流水号。其中，流水号通过incr和incrby来生成。

  TIME命令返回时间四元组，处理为毫秒数。

- zookeeper临时顺序节点生成id。

  定义一个节点，创建临时顺序子节点，根据返回的节点名称，取序号部分组合得到id.

## 分布式ID生成速度如何提高？

放到缓存或者消息队列里

数据分布方式包括：哈希取模，一致性哈希

## mongoDB的自动分片有什么问题？

mongoDB支持auto sharding，自动分片。但不太可控，不知道什么时候会进行数据迁移。数据迁移过程中会有大粒度的锁，读写被阻塞，业务会有抖动和毛刺。这些是业务不能接受的，于是后来又被我们弃用。

58同城也用过两年mongoDB，后来发现auto sharding不太可控，不知道什么时候会进行数据迁移，数据迁移过程中会有大粒度的锁，读写被阻塞，业务会有抖动和毛刺，这些是业务不能接受的，于是后来又被我们弃用。

# 微服务

## [互联网架构，究竟为啥要做服务化？](https://mp.weixin.qq.com/s/S6ga8y88qaAjbKjuKMrowQ)

## 服务化解决的问题有哪些？

到处复制代码：数据库访问。

复杂性扩散：引入新的组件或者发现bug，就要多处同时修改代码。

库的复用与耦合：代码库的版本与业务代码耦合，不方便升级。

业务相互影响：低效的SQL会影响其他业务。

数据库表的耦合：join语句的泛滥，让共用的数据库中的表严重耦合，难以垂直拆分。

## 服务化的好处有哪些？

通过RPC访问数据：方便调用。

代码复用：维护升级时不需要多处修改。

屏蔽底层细节：利于专注，解除缓存和分库分表都不需要考虑了。

使SQL质量得到了保障：可以由更资深的工程师保障。

服务化通过数据库解耦：隔离的数据库，方便拆分扩容。

提供有限接口：集群扩展可以应对高并发访问。