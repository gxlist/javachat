# 概述

## redis是不是单线程的？

redis的单线程是指网络请求模块使用了一个线程，使用epoll和简单的事件框架处理多个连接请求，适合多连接而少请求，其他模块仍然是多线程。

redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。

## redis的线程安全是怎么实现的？

使用了线程封闭的观念，把操作封闭在一个线程，如果需要多个redis符合操作，就需要分布式锁。setnx可以写入唯一的数据，这样抢到锁，并设置过期时间。

## redis的数据添加过程是怎样的？

哈希槽；

## redis会不会回收数据？

添加新数据，或者执行新命令，就会检查内存满，然后决定是否回收。

## Redis的缓存淘汰策略是什么？

1. volatile-**lru / ttl / random**：从设置了过期时间的数据集合（server.db[i].expires）中挑选**最近最少使用 / 即将过期 / 任意**的数据淘汰。
1. allkeys-**lru / random**：从数据集（server.db[i].dict）中挑选**最近最少使用 / 任意**的数据淘汰。
1. no-enviction（驱逐）：禁止驱逐数据。

## Redis如何设置密码及验证密码？

设置密码：config set requirepass 123456，授权密码：auth 123456

## redis是如何持久化的

rdb和aof；

##  jedis 和 redisson 有哪些区别？

jedis是Redis官方提供的，功能全面。redisson是第三方提供的。只提供了缓存功能。





# 数据结构

## redis的数据结构与对象

简单动态字符串(SDS)：用于代替C字符串。SDS是由字符数组、字符长度和剩余长度构成的结构体实现的。相对于C字符串的优点有：常数复杂度获取字符串长度，杜绝缓冲区溢出，减少修改字符串长度时所需的内存重分配次数，二进制数据安全，兼容部分C字符串函数。

链表(双向)：用于作为列表键、发布/订阅、慢查询、监视器的实现，客户端状态信息的保存和客户端输出缓冲区的构建。

字典：用于作为Redis数据库和哈希键的实现。字典有两个哈希表，分别在平时和rehash时使用。哈希算法是MurmurHash2，键冲突通过链地址法来解决。哈希表的扩容或收缩需要渐进rehash到新表，持有2个引用，工作时用0号，2方倍扩容时给1号表分配空间，并把0号的和新键值对重新映射到1号，rehashidx递增，然后把0号引用指向新表，rehashidx复位为-1，原表回收。

跳跃表：用于作为有序集合键的底层实现之一和集群节点中的内部数据结构。跳跃表由保存配置信息(头尾节点和长度)的zskiplist和表示节点的zskiplistNode构成。层高为1-32的随机数。多个节点的分值可以相同，但成员对象必须唯一。节点按照分值和成员对象大小依次排序。

整数集合：用于作为集合键的底层实现之一。整书集合是以有序、无重复的方式保存集合元素的数组实现的，可以根据新添加元素更大的类型，升级数组类型。升级操作为整数集合带来了兼容短类型的灵活性，节约了内存，但不能降级。

压缩列表：用于作为列表键、哈希键和有序集合的实现之一(数据项少或小时优先)。压缩列表是由一系列特殊编码的连续内存块组成的顺序型数据结构，可以包含多个节点，每个节点保存一个字节数组或者整数值。节点的增删可能会引发连锁更新，但因几率低而不必担心。

对象：上述数据结构实现了Redis对象，对象层的类型包括字符串、列表、哈希、集合、有序集合等。对象可以封装命令，以及根据不同场景使用不同的实现。Redis对象系统实现了基于引用计数技术的内存回收，通过引用计数技术实现了对象共享。

## redis对象的编码实现是什么？

字符串对象的编码可能是int(类型整数), raw(SDS分配2次内存)或者embstr(字符串39字节，分配一次内存).

列表对象的编码可能是压缩列表(元素长度64字节，数量512)或者链表。

哈希对象的编码可能是压缩列表(元素长度64字节，数量512)或者哈希表。

集合对象的编码可能是整数集合(类型整数，数量512)或者哈希表。

有序集合的编码可能是压缩列表(元素长度64，数量128)或者跳跃表。

# 持久化和复制

## redis的持久化？

有rdb和aof两种方式。

save/bgsave以阻塞/子进程非阻塞的方式生成当前内存快照的RDB文件，默认每隔100ms检查是否符合配置的多级保存条件。如果配置了AOF，就会优先追加到命令文本格式的AOF文件。

对于aof, appendfsync选项配置为always，会在每一步操作后同步刷盘，停机就丢失一个事件循环的数据。配置为everysec会丢失1秒。配置为no则由操作系统决定。

## redis服务器的工作过程

Redis服务器是一个事件驱动程序，需要处理文件事件和时间事件。

redis的基于reactor模式的网络事件处理器，是把socket操作封装为文件事件的文件事件处理器。使用IO多路复用程序(性能高，单线程运行模型简单)监听多个套接字，并根据套接字目前的任务来为套接字关联不同的事件处理器。

文件处理器包括套接字、IO多路复用程序、文本事件派发器和事件处理器。

文件事件是对套接字操作的抽象。当被监听的套接字准备好执行连接应答accept，读写read/write，关闭close等操作时，产生对应的文件事件。
io多路复用程序将并发的文件事件放到一个队列里，以有序、同步、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件都处理完后，才传送下一个。兼顾单线程循环的简单和异步操作的高性能。

套接字产生读写操作时，优先处理读操作。
文件事件处理器包括连接应答、命令请求、命令回复、复制处理器等。

时间事件包括定时事件和周期性事件。应用实例是serverCron函数。

## redis主从复制的过程

1. 连接建立阶段：

   - 保存主节点信息：从机执行`slave of <主ip> <主port> `命令，成为目标机的从机，设置主节点属性后向客户端返回OK。

   - 创建套接字连接：从机创建socket连接，成为主节点的客户端，然后为这个套接字关联一个专门用于处理复制的文件事件处理器。

   - 从机发送 `ping` 命令：如果返回不完整的命令或者错误，就重建连接。如果返回 pong ，则表示连接正常，可以复制。

   - 身份验证：如果从服务器设置了masterauth选项，就要发送 auth  命令进行*验证*，如果密码与主服务器设置的 requirepass 选项相同，或者都没设置，就可以复制。不同或者未完全设置则返回错误。

   - 发送节点端口信息：通过`replconf listening-port ` 命令发送监听端口号，保存后在查询复制信息时打印到回复。

1. 同步阶段：

   从服务器向主服务器发送*psync*命令，主服务器此时也会成为从服务器的客户端。在完整/部分重同步时，将缓冲的命令操作发送给从服务器执行。这样成为相互的客户端，就可以相互发送命令和回复。

1. 命令传播阶段

   主节点将自己执行的写命令发送给从节点，从节点接收命令并执行。从服务器默认每秒发送命令` replconf ack <replication_offset> `检测配置主从连接，根据复制偏移量检测命令丢失并补发。

1. 复制阶段

   2.8之前版本的复制使用sync命令复制，缺点不少，具体包括：主服务器执行bgsave命令来生成RDB文件，耗CPU、内存和磁盘IO资源。向从服务器发送这个文件，耗带宽。从服务器载入这个文件，会长时间阻塞，无法处理其他请求。在断线重新复制的时候，要重新生成RDB文件并发送。

   2.8版本的redis使用psync命令代替sync，psync命令包括处理初次复制的完整同步和处理断线后复制的部分同步功能。如果断线时间过长，主节点不再保存中断期间的写命令，就只能全量复制。

## redis主从复制的作用

数据冗余：主从复制实现了数据热备份，是持久化之外的一种数据冗余方式。

故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。

负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。

高可用的基础：是哨兵和集群的基础。

## redis部分重同步的实现

主从服务器分别维护一个**复制偏移量**，分别为发送和接收到的累计字节数。主从服务器的偏移量的比较可以知道状态是否一致。断线的从机偏移量滞后，重连后发送psync命令，向主机报告当前偏移量。

**复制积压缓冲区**是主服务器维护的一个默认1M的FIFO队列，用于缓冲复制的命令内容，并给每个字节记录偏移量。重连的从机的复制偏移量之后的数据仍然在复制积压缓冲区里，就部分重同步。否则执行完整重同步。缓冲区大小根据重连时间和每次写入字节数来设置。

主从服务器都有自己的**运行ID**，在启动时自动生成，由40个随机的十六进制字符组成。从服务器初次复制时，会得到并缓存主服务器的运行ID。重连后检查ID是否一致，一致就部分重同步，否则执行完整重同步。

psync的调用方法有2种：

从服务器没有复制过(包括slaveof no one)，就发送 `psync ? -1` 命令，进行完整重同步。

否则，发送 `psync <缓存的主runid> <从offset>`。主服务器则返回 +fullresync <主runid> <主offset> 命令要求完整重同步，或者返回 +continue 命令要求部分重同步，或者返回 -err 表示主服务器版本低于2.8，要换sync的完整重同步。

## 读写分离要注意的问题有哪些？

延迟与不一致问题：由异步复制导致，可能的优化包括优化网络环境，监控主从节点延迟，使用集群扩展负载，设置从节点的`slave-serve-stable-data`参数为`no`，让从节点只能响应少数命令。

数据过期问题：3.2版本之后，从节点读取数据增加了数据过期的判断。

故障切换问题：主从节点宕机，需要及时修改应用程序读写Redis数据的连接。使用哨兵来自动切换。

## 复制中断的原因有哪些？

复制超时和复制缓冲区溢出。

判断超时可以让主节点释放连接和资源，让从节点重新连接。

## 复制阶段连接超时会导致的问题，以及解决方案有哪些？

1. 数局同步阶段：主节点在fork子进程+保存RDB文件时耗时过多，可能会导致从节点长时间收不到数据而触发超时；此时从节点会重连主节点，然后再次全量复制，再次超时，再次重连……这是个悲伤的循环。

   为了避免这种情况的发生，除了注意Redis单机数据量不要过大，另一方面就是适当增大repl-timeout值。

1. 命令传播阶段：如前所述，在该阶段主节点会向从节点发送PING心跳检测命令，频率由repl-ping-slave-period控制；

   该参数应明显小于repl-timeout值(后者至少是前者的几倍)。

1. 慢查询导致的阻塞：如果主节点或从节点执行了一些慢查询（如keys *或者对大数据的hgetall等），导致服务器阻塞，无法响应复制连接中对方节点的请求，可能导致复制超时。

   优化或禁止慢查询。

## 什么时候回发生全量复制？

第一次复制：是全量复制，如果数据量大，就要避开流量高峰。链式节点复制。

主节点重启：宕机重启，runid会发生变化，只能进行全量复制。使用哨兵进行自动故障转移。安全重启`debug reload`支持增量复制，会重新加载RDB文件，可能导致阻塞。

从节点重启：保存的主节点的runid会丢失，只能全量复制。

网络中断：短时间的网络中断，可以根据复制偏移量补充数据。长时间网络中断，丢失的数据超过了复制积压缓冲区的存储，只能全量复制。

# 哨兵和集群

## 哨兵Sentinel是什么？

sentinel是redis的高可用解决方案，具有监控、提醒和自动故障转移的功能。由一个或多个sentinel实例组成的Sentinel系统可以监视多个主服务器及其从服务器，并在主服务器下线后，自动选择一个从服务器代替原来的主服务器，然后向原先的从服务器发送新的复制命令，原先的主服务器重新上线后设置为从服务器。

启动命令是：
redis-sentinel /path/sentinel.conf 或者 redis-server /path/sentinel.conf –sentinel

当一个Sentinel启动步骤：初始化服务器(不载入数据文件)，将普通redis服务器使用的代码换成Sentinel专用的代码(端口和载入的命令有差别)，初始化  Sentinel  状态和配置的监视主服务器列表，创建连向主服务器的网络连接(包括命令连接和对__sentinel__:hello频道的订阅连接)。

Sentinel  默认以10s的周期向被监视的主服务器发送info命令，并通过回复获取主服务器当前信息，包括运行ID、角色和从服务器列表。当sentinel  发现新的从服务器出现时，不仅会为新的从服务器创建实例结构，还会同样创建命令和订阅连接，以及相同频率发送info命令。

默认sentinel 服务器以2s的周期向所有被监视的主从服务器发送命令：PUBLICSH __sentinel__:hello  “<s_ip>,<s_port>,<s_runid>,<s_epoch>,<m_name>,<m_ip>,<m_port>,<m_epoch>”，这条命令向服务器的  __sentinel__:hello 频道发送了一条消息。当Sentinel 与一个主服务器或者从服务器建立起订阅连接之后，Sentinel  就会通过订阅连接，向服务器发送订阅命令： subscribe __sentinel__:hello  ，订阅会持续到断开连接。这样，Sentinel对这个频道同时发送和接收消息，发送的消息就会被其他监视该服务器的Sentinel哨兵接收到，然后更新对发送消息的Sentinel和该服务器的信息，就可以知道其他Sentinel  的存在。

当Sentinel通过频道信息发现一个新的Sentinel，就会创建这个新Sentinel的结构信息和双向的命令连接，最终监视同一台主服务器的多个Sentinel会两两互连。但不会建立订阅连接。

默认Sentinel以1s的周期向所有建立了命令连接的实例发送 ping  命令，并通过回复来判断是否在线。其中，+pong、-loading、-masterdown是有效回复。down-after-milliseconds选项设置的断线时间超时，主从服务器树会被主观下线。然后Sentinel为了确认客观下线，就发送命令(sentinel  is-master-down-by-addr   <current_epoch> )询问其他Sentinel，如果回复统计的下线数量超过了quorum配置，就判断为客观下线。监视下线服务器的各个Sentinel会协商选举出首领Sentinel，执行故障转移。选择保存最新信息的从服务器，发送slaveof  no one 命令，并10s周期发送info命令来轮询角色，发送slaveof  命令来修改其他从服务器的复制目标，原先的主服务器在重新上线后，通过 slave of 命令修改角色设置为从服务器。

选举规则(raft算法)：所有在线的sentinel都可以参选，每次选举epoch自增，每个发现客观下线的Sentinel都会要求其他Sentinel将自己设置为首领Sentinel(发送sentinel   is-master-down-by-addr命令，runid参数由*符号变为发现者的运行ID)，规则是抢占(可以估计错开超时时间或者quorum配置数量，可以减少冲突)，拒绝后来者，返回已当选的局部首领Sentinel的运行ID和纪元信息。被半数以上Sentinel设置成局部首领Sentinel会成为首领Sentinel。唯一性由epoch的唯一选举决定。没选举出来，就过一段时间再选举。

## redis的集群是怎么样的？

redis集群通过分片来进行数据共享，并提供复制和故障转移功能。

cluster meet   可以添加节点，cluster nodes 可以查看已添加的节点。集群节点为新节点创建数据结构，发送meet消息。新节点也创建数据结构，返回pong消息。集群节点返回ping消息。握手完成后，集群节点通过gossip协议将新添加的节点信息传播给其他节点。

redis集群通过分片的方式保存键值对：数据库被分成16384个槽，由键哈希后投放到其中，都有节点在处理时，集群上线，否则下线。cluster add slots 0 1 2 … 5000 这样添加slot。可以通过cluster info查看。

节点通过slots字节位数组来记录所负责的槽，并在改动后发送该数据到其他集群节点，其他集群节点保存到所维护的node成员节点的字节位数组属性中。状态的slots指针数组记录了16384个槽的指派信息，指向节点结构。这样，就构成了节点和槽的双向链接。

节点执行设置数据的命令，先对键的crc16校验和截取16384位得到槽的索引号，通过节点检查是不是自己负责，否则从状态的指针数组找到对应的节点，向客户端返回moved错误并引导客户端重定向到对应的节点。集群不打印这个错误，单机打印。另外，集群只能使用0号数据库，单机可以使用全部。除了计算索引号得到键到槽的链接，节点还在状态中的跳跃表指针属性来保存从槽到键的链接关系。使用跳跃表机制的  cluster getkeysinslot <slot号>  命令可以返回最多count个属于槽slot的键。这样就构成了键与槽的双向链接。

redis集群的重新分片可以将任意数量已经指派的槽重新指派给目标节点，并且键值对数据也移动到新节点。集群管理软件redis-trib通过向源节点和目标节点发送命令来重新分片。步骤包括：对目标节点发送命令 cluster setslot 

导入和迁移命令的实现是由维护在状态中的导入槽指针数组来记录源节点和目标节点的。

重新分片的迁移过程中，键值对分别保存在两端节点。那么，客户端发送某个键的处理命令时，如果源节点发现还有，就返回，否则返回ask错误，引导重定向到目标节点，先发送asking命令打开客户端的redis_asking一次性标识使得对正在迁移的槽的操作获得允许，然后重新发送要执行的命令。集群同样不打印这个错误，单机打印。

ask错误和moved错误都会导致重定向，区别在于：moved错误代表槽的负责权已经从一个节点转移到了另一个节点，客户端记录对应处理节点，以后就只向这个节点发。ask错误只是两个节点在迁移槽的过程中的一种临时措施，不对后续的操作有影响。

cluster replicate <node_id> 可以让接收命令的节点成为node_id的从节点，并开始复制。保存主节点的信息，修改自己的角色状态，调用复制方法。该命令会扩散到其他集群节点。

集群中的节点会定期向其他节点发送ping消息，以此来检测是否在线，如果超时，就标记为疑似下线pfail，并添加到该节点的下线报告的链表中。如果半数以上的节点都报告某节点疑似下线，就会被标记为正式下线，然后向集群广播下线消息。

当一个从节点发现子集正在复制的主节点已下线，就会开始故障转移。步骤包括：一个从节点被选中来执行slave on  one命令，成为新的主节点，撤销已下线主节点的槽指派，并将这些槽指向自己。向集群广播pong消息，让其他节点知道。然后开始处理槽请求，完成故障转移。

跟首领哨兵的选举类似，新的主节点的选举也是使用raft算法。

节点发送的消息有5种：meet, ping, pong, fail, publish. 其中meet, ping,  pong消息通过gossip协议交换信息，fail消息通过集群广播直接通知，比gossip快。publish命令不仅会向channel频道发送消息，还会向集群广播一条publish消息，所有接收到这条publish消息的节点都会向channel频道发送message消息。实际上，要让集群节点都执行publish命令，最简单的方法就是向所有节点都广播publish命令，而且已经用于复制命令，但不符合”节点之间通过收发消息来通信”的设计原则，就没有使用。

## redis的集群方案有哪些？

codis，redis cluster.集群没有复制，则宕机的槽不可用。主从复制无法保证高可用，没有解决master写的压力。tempoxy的代理层需要维护高可用。

## redis集群如何同步？

主从复制。

## redis的自动故障转移过程是什么？有没有缺点？

Sentinel通过周期ping检测到主服务器下线，经过集群确认，选择一个从服务器，升级为主服务器，原先的主服务器再次加入，则变为从服务器。

缺点是：主从模式的切换，需要时间，会丢数据。没有解决master写的压力。

## redis的客户端有哪些？

Java客户端有：Redisson、Jedis等等，官方推荐使用Redisson。

Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；

Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。

## redis创建普通客户端被关闭的原因包括哪些？

1. 进程退出。
1. 发送的命令不符合格式。
1. 被client kill命令关闭。
1. 空转时间超时。
1. 客户端发送命令超过了输入缓冲区(1G)。
1. 回复的消息大小超过了输出缓冲区。

# 功能

## redis 有哪些功能？

缓存，队列，排名，排序，事务，消息订阅。

## 怎么保证缓存和数据库数据的一致性？

## redis 怎么实现分布式锁？

watch

set nx

## redis 分布式锁有什么缺陷？

宕机。

## redis的发布订阅功能

redis的发布与订阅功能由publish， subscribe，  psubscribe等命令组成。通过把客户端信息在服务器的订阅频道字典的链表的增删实现频道的订阅/退订，通过把客户端订阅的模式信息在服务器的订阅模式链表的增删来实现模式的订阅/退订。如果多个客户端订阅了同一个模式，怎么处理。publish命令要求服务器将消息发送给channel频道的所有订阅者，以及模式匹配的订阅者。

pubsub 用于查看频道或者模式的订阅信息。pubsub channels [pattern]  可以返回服务器当前被订阅的频道。pubsub numsub [channel-1 …channel-n]  接受任意多个频道作为输入，并返回其订阅客户端的数量。pubsub numpat 子命令可以返回服务器当前被订阅模式的数量。

## redis的事务是怎么实现的？

redis通过multi, exec,  watch等命令实现事务功能。multi命令启动事务，如果不是exec/discard/watch/multi命令，都会添加到事务状态mstate的命令属性事务队列(命令数组)中，并返回queued。exec命令使队列中保存的命令执行。watch命令是一个了乐观锁，如果监视的键被改动，exec命令就拒绝执行事务。

数据库结构体中保存着一个监视键的字典，字典的值则是客户端链表。修改数据的命令执行完后，都会检查监听键字典，如果有监听的，就打开redis_dirty_cas 标识，表示事务安全性被破坏。

redis的事务队列中命令的执行具有原子性，命令入队错误将导致所有的命令不能执行，运行时错误则不影响继续执行。事务不支持回滚。一致性拒绝入队错误，单独处理执行错误，停机的持久化恢复使数据一致。隔离性通过单线程不中断的方式来保证。持久性是事务执行后就持久化到磁盘，只有在AOF的appendfsync选项的配置为always时，命令执行后同步刷盘，才具有持久性。如果事务入队命令的最后是save命令，就可以保证持久性，但效率较低。

## redis的使用场景有哪些？

1. 会话缓存
1. 全页缓存
1. 队列（list结构的队列，消费者下线，会丢失消息）
1. 排行榜/计数器：ZRANGE [column] 0 10 WITHSCORES
1. 发布-订阅（一对多的队列）

# 性能

## redis的优缺点是什么？

优点是：速度快，数据类型丰富，支持事务，丰富的特性可以用于缓存，消息，按照key设置过期时间（expire,persist永久）等。

缺点是：容量受物理内存限制

## redis为什么这么快

内存操作，采用单线程，非阻塞的io多路复用，多种实现的数据结构适合不同场景，自定义的vm。

## redis性能问题的原因和解决方案是什么？

master写内存快照，会阻塞主线程的工作，服务暂停。那么，master不要写内存快照。

master AOF持久化，会让AOF文件变大，降低重启的恢复速度。那么，可以让slave从机开启AOF持久化，并且每秒同步一次。

主从复制的性能，取决于传输速度和连接的稳定性。那么，让主从机位于同一个局域网或者机架。

主库读写压力大就不用从库，多个从库使用链表结构。

## redis的内存优化？

用散列表。

## 为什么线上Redis禁止使用Keys正则匹配操作？

Keys正则匹配命令，导致`redis`锁住，CPU飙升。缓存不能查询，所有支付链路卡住。高并发的QPS大，线程多，容易内存溢出而宕机。等十几秒正则匹配结束后，同时查询会不会让Redis据库宕机呢？

其他危险的命令包括：lushdb, flushall, CONFIG等，复杂度都是O(n)。

解决方案是：使用`scan`命令分批扫描，来改良`keys`和`SMEMBERS`命令。