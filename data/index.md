# 硬件

## 机械硬盘的存储包括哪些概念？

https://blog.csdn.net/vict_wang/article/details/82848680

## 数据库存储日期格式时，如何考虑时区转换问题？

答：使用TimeStamp , 原因参照：Java编程中遇到的时区转换问题。

# 索引

## [数据库索引，到底是什么做的？](https://mp.weixin.qq.com/s/YMbRJwyjutGMD1KpI_fS0A)

## 索引的优点有哪些？

减少扫描数据量，避免排序和临时表，将随即io变为顺序io. 加索引的生效条件包括：非空，无函数或计算，多列索引的左前缀原则，范围列在最后过滤，通过触发计算不可索引列的内容新增一个可索引列。非空TB级别数据的存储不再使用索引，而是使用元数据找到数据存储文件的位置。

## 什么情况不适合建索引？

如果索引策略和数据检索需求严重不符的话，建立索引反而会降低查询性能。因此在实际使用当中，应该充分考虑到 索引的开销，包括磁盘空间的开销及处理开销（如资源竞争和加锁）。例如，如果数据频繁的更新或删加，就不宜建立索引。

## 什么是聚簇索引？

聚簇索引不是单独的索引类型，而是一种适合磁盘介质读多写少的数据存储方式，如InnoDB的聚簇索引实际上在同一个结构中保存了B+Tree索引和数据行。因为数据行存储位置唯一，所以一个表只有一个聚簇索引。InnoDB依次选择主键列、唯一的非空索引列和隐式主键列来作为聚簇索引。优点是批量读取减少io，访问数据的速度快，覆盖索引可以直接使用主键。

## 什么是覆盖索引？

覆盖索引是包含要查询的数据的索引，如果查询结果和过滤条件都超过了索引列范围，可以先扩展多列索引到过滤条件，然后通过覆盖索引查询出主键列，再联合查询聚簇索引得到所需要的数据。

## 如何使用索引扫描排序？

索引扫描排序在explain的type列值为"index"（该列的"ref"值才是使用索引，Extra列的"Using Index"是索引覆盖），另一种生成有序结果的操作是排序。mysql可以使用一个索引列同时实现排序和查找行的功能。索引排序的生效条件是：索引的列顺序和"order by"子句排序的顺序完全一致，并且所有列的排序方向都一样; 关联了多张表的查询需要"order by"子句引用的字段都位于第一个表; 满足索引的最左前缀的要求（除非前导列为常量）。使用索引做排序的一个最重要的用法是当查询同时有order by和limit子句的时候进行延迟关联。

## 聚簇索引和非聚簇索引的区别是什么？

1.  聚集索引。表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。对于聚集索引，叶子结点即存储了真实的数据行，不再有另外单独的数据页。 在一张表上最多只能创建一个聚集索引，因为真实数据的物理顺序只能有一种。
1. 非聚集索引。表数据存储顺序与索引顺序无关。对于非聚集索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致。

​    总结一下：聚集索引是一种稀疏索引，数据页上一级的索引页存储的是页指针，而不是行指针。而对于非聚集索引，则是密集索引，在数据页的上一级索引页它为每一个数据行存储一条索引记录。

聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。

聚簇索引中的每个叶子节点包含主键值、事务ID、回滚指针(rollback pointer用于事务和MVCC）和余下的列(如col2)。

InnoDB的的二级索引的叶子节点存放的是KEY字段加主键值。因此，通过二级索引查询首先查到是主键值，然后InnoDB再根据查到的主键值通过主键
索引找到相应的数据块。

## 数据库日志的作用是什么？

大多数存储引擎实现了预写式日志，事务日志被持久化后，内存数据可以异步刷盘，共写2次。如果异步刷盘前服务崩溃，就在重启后按照预写的事务日志自动优先重新执行一遍。

## 值较少的列为什么不适合添加索引？

因为数据页中的数据的顺序和索引队列中键值的顺序并不是一致，根据索引获取非索引列的数据，需要多次随机读取磁盘文件。io效率甚至可能不如全表扫描。



a、非聚簇索引存储了对主键的引用，如果select字段不在非聚簇索引内，就需要跳到主键索引（上图中从右边的索引树跳到左边的索引树），再获取select字段值

b、如果非聚簇索引值重复率高，那么查询时就会大量出现上图中从右边跳到左边的情况，导致整个流程很慢

c、如果where值重复率高的字段，select用了limit，只查较少数据，也就是跳的次数很少的情况下，还是可以建索引的（后来想想也没必要，limit限制了数量，全表扫描也很快，除非字段值是排序的，必须扫描完前面的所有值）

d、如果没有3这个前提，则不建议在值重复率高的字段上建索引，因为查询效率低，还需要维护索引



## 重复索引和冗余索引的区别？

重复索引：表示一个列或者顺序相同的几个列上建立的多个索引。

冗余索引：两个索引所覆盖的列重叠

冗余索引在一些特殊的场景下使用到了索引覆盖，所以比较快。

## 数据库事务特性有哪些？

原子性，一致性，隔离性，持久性。

## 数据库的隔离级别有哪些？

读未提交，读已提交，可重复读，序列化。

分别解决了脏读、重复读、不可重复读、幻读。

## LevelDB的介绍

levelDB只能本机调用，网络调用需要自行封装服务层。数据结构是跳表，操作策略是对磁盘顺序写的数据日志结构进行归并（LSM树）。跳跃表实际上是二叉平衡树的一种变形结构，通过将一个有序链表进行升维操作，从而减少每一层上需要遍历的数据数量，提高速度。跳表的结构在插入数据的过程中会发生变化。

LevelDB收到新的消息时会同步预占100MB磁盘空间的Log文件的顺序写和内存中跳表结构的MemTable区域的写入。MemTable区域达到默认的大小(6MB)后，就会标记为Immutable，并开启一个新的MemTable区域。被标记的区域数据经过Compact过程去掉已消费(被标记为删除)和格式错误的数据，然后写入磁盘上默认大小为2MB的SSTable文件(后缀.sst，由默认大小4kb的block块构成，最后一块是记录了每个数据块起始位置的索引块，可以缓存到内存中)。具有管理功能的Manifest文件记录了.sst文件的元数据信息。

# 数据库架构

## 分片解决了什么问题？

“**分片**”，也就是水平切分，它是用来解决数据量大的问题。

## 常用的数据路由方法有几种？介绍一下。

一旦进行分片，就会面临“**数据路由**”的问题，来了一个请求，要将请求路由到对应的数据库分片上。互联网常用的数据路由方法有三种：

（1）一个是**按照数据范围路由**，比如有两个分片，一个范围是0-1亿，一个范围是1亿-2亿，这样来路由。

这个方式的**优点**是非常的简单，并且扩展性好，假如两个分片不够了，增加一个2亿-3亿的分片即可。

这个方式的**缺点**是：虽然数据的分布是均衡的，每一个库的数据量差不多，但请求的负载会不均衡。例如有一些业务场景，新注册的用户活跃度更高，大范围的分片请求负载会更高。

（2）二个是**按照hash路由**，比如有两个分片，数据模2寻库即可。

这个方式的**优点**是路由方式很简单，数据分布也是均衡的，请求负载也是均衡的。

这个方式的**缺点**是如果两个分片数据量过大，要变成三个分片，数据迁移会比较麻烦，即扩展性会受限。

（3）三个是**路由服务**。前面两个数据路由方法均有一个**缺点**，业务线需要耦合路由规则，如果路由规则发生变化，业务线是需要配合升级的。路由服务可以实现业务线与路由规则的解耦，业务线每次访问数据库之前先调用路由服务，来知道数据究竟存放在哪个分库上。

## 为什么要进行分组和复制？

“**分组**”与“**复制**”，这解决的是扩展读性能，保证读高可用的问题。

根据经验，大部分互联网的业务都是读多写少。

淘宝、京东查询商品，搜索商品的请求可能占了99%，只有下单和支付的时候有写请求。

58同城搜索帖子，察看列表页，查看详情页都是读请求，发布帖子是写请求，写请求的量也是比较少的。

大部分互联网的场景都读多写少，一般来说读性能会最先成为瓶颈，怎么快速解决这个问题呢？

我们通常使用读写分离，扩充读库的方式来提升系统的读性能，同时多个读库也保证了读的可用性，一台读库挂了，另外一台读库可以持续的提供服务。